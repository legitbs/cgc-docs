<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
    <meta content='width=device-width, initial-scale=1' name='viewport'>
    <title>Running Intel PIN on DECREE Challenge Binaries</title>
    <link href="../../../assets/stylesheets/application.css" rel="stylesheet" />
  </head>
  <body class='cgc-release-documentation cgc-release-documentation_walk-throughs cgc-release-documentation_walk-throughs_pin-for-decree cgc-release-documentation_walk-throughs_pin-for-decree_index'>
    <div id='container'>
      <div id='nav_col'>
        <div id='logo'>
          <a href='/'>
            CGC Docs, published by Legitimate Business Syndicate
          </a>
        </div>
        <div id='nav'>
          <ul>
            <li>
              <a href='/'>CGC Docs</a>
            </li>
            <li class='hdr'>Event-FAQ</li>
            <li>
              <a href='/Event-FAQ/event_faq/'>Event FAQ</a>
            </li>
            <li class='hdr'>cb-testing</li>
            <li>
              <a href='/cb-testing/cb-acceptance/'>cb-acceptance</a>
            </li>
            <li>
              <a href='/cb-testing/cb-replay/'>cb-replay</a>
            </li>
            <li>
              <a href='/cb-testing/cb-replay-pov/'>cb-replay-pov</a>
            </li>
            <li>
              <a href='/cb-testing/cb-test/'>cb-test</a>
            </li>
            <li>
              <a href='/cb-testing/poll-validate/'>poll-validate</a>
            </li>
            <li class='hdr'>cgc-release-documentation/newsletter</li>
            <li>
              <a href='/cgc-release-documentation/newsletter/ipc/'>News Letter 1: IPC</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/newsletter/cpp/'>News Letter 2: C++</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/newsletter/ctf/'>News Letter 3: CTF</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/newsletter/template/'>News Letter X: Template</a>
            </li>
            <li class='hdr'>cgc-release-documentation/walk-throughs</li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/building-a-cb/'>Building a Challenge Binary</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/cgc-repository/'>CGC Repositories</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/debugging-a-cb/'>Debugging a Challenge Binary</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/pin-for-decree/'>Running Intel PIN on DECREE Challenge Binaries</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/running-the-vm/'>Running the Virtual Machine</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/scoring-cbs/'>Scoring a Challenge Binary Set</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/submitting-a-cb/'>Submitting a Challenge Binary</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/testing-a-cb/'>Testing a Challenge Binary</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/understanding-poll-generators/'>Understanding Poll Generators</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/understanding-cfe-povs/'>Understanding Proofs of Vulnerability in CFE</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/using-the-network-appliance/'>Using the Network Appliance</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/virtual-competiton/'>Virtual Competition</a>
            </li>
            <li>
              <a href='/cgc-release-documentation/walk-throughs/ptrace-for-decree/'>Writing an Instruction Tracer for DECREE Challenge Binaries Using ptrace</a>
            </li>
            <li class='hdr'>cgc2elf</li>
            <li>
              <a href='/cgc2elf/cgc2elf/'>cgc2elf</a>
            </li>
            <li class='hdr'>cgcef-verify</li>
            <li>
              <a href='/cgcef-verify/cgcef_verify/'>cgcef_verify</a>
            </li>
            <li class='hdr'>libcgc</li>
            <li>
              <a href='/libcgc/allocate/'>allocate</a>
            </li>
            <li>
              <a href='/libcgc/cgcabi/'>CGC ABI</a>
            </li>
            <li>
              <a href='/libcgc/deallocate/'>deallocate</a>
            </li>
            <li>
              <a href='/libcgc/fdwait/'>fdwait</a>
            </li>
            <li>
              <a href='/libcgc/random/'>random</a>
            </li>
            <li>
              <a href='/libcgc/receive/'>receive</a>
            </li>
            <li>
              <a href='/libcgc/terminate/'>_terminate</a>
            </li>
            <li>
              <a href='/libcgc/transmit/'>transmit</a>
            </li>
            <li class='hdr'>libcgcef</li>
            <li>
              <a href='/libcgcef/cgc_executable_format/'>CGC Executable Format</a>
            </li>
            <li class='hdr'>libpov</li>
            <li>
              <a href='/libpov/libpov/'>libpov</a>
            </li>
            <li>
              <a href='/libpov/type1_negotiate/'>type1_negotiate</a>
            </li>
            <li>
              <a href='/libpov/type2_negotiate/'>type2_negotiate</a>
            </li>
            <li>
              <a href='/libpov/type2_submit/'>type2_submit</a>
            </li>
            <li class='hdr'>network-appliance</li>
            <li>
              <a href='/network-appliance/cb-packet-log/'>cb-packet-log</a>
            </li>
            <li>
              <a href='/network-appliance/cb-proxy/'>cb-proxy</a>
            </li>
            <li>
              <a href='/network-appliance/verify-rules/'>verify-rules</a>
            </li>
            <li class='hdr'>poll-generator</li>
            <li>
              <a href='/poll-generator/generate-polls/'>generate-polls</a>
            </li>
            <li class='hdr'>pov-xml2c</li>
            <li>
              <a href='/pov-xml2c/pov-xml2c/'>pov-xml2c</a>
            </li>
            <li class='hdr'>service-launcher</li>
            <li>
              <a href='/service-launcher/cb-server/'>cb-server</a>
            </li>
            <li class='hdr'>virtual-competition</li>
            <li>
              <a href='/virtual-competition/ti-client/'>ti-client</a>
            </li>
            <li>
              <a href='/virtual-competition/ti-rotate/'>ti-rotate</a>
            </li>
            <li>
              <a href='/virtual-competition/ti-server/'>ti-server</a>
            </li>
          </ul>
        </div>
      </div>
      <div id='main_col'>
        <div id='title'>
          <h1>Running Intel PIN on DECREE Challenge Binaries</h1>
        </div>
        <div id='content'>
          <p>This walk-through will guide you through the process of building and running the <a href="https://software.intel.com/sites/landingpage/pintool/docs/65163/Pin/html/index.html#EXAMPLES">"Simple Instruction Count"</a> pintool on a DECREE Challenge Binary.</p>
          
          <p>A small DECREE syscall emulation library is provided to users as a way to test their CBs using Intel's PIN architecture. The source for the sample pintool is attached at the end of the walkthrough for reference. Please note that this library is not a high fidelity model of DECREE and there will be discrepancies between native execution and Intel PIN instrumented execution.</p>
          
          <h2 id="prerequisites">Prerequisites</h2>
          
          <ol>
            <li>The latest DECREE virtual machine.</li>
            <li>A PIN distribution (Version 67254 from Sep 02, 2014 was used for this walk-through)</li>
            <li>A CB to test.</li>
          </ol>
          
          <h2 id="the-syscall-emulator">The syscall emulator</h2>
          
          <p>The DECREE OS exposes 7 different system calls to CBs: <code class="highlighter-rouge">_terminate</code>, <code class="highlighter-rouge">transmit</code>, <code class="highlighter-rouge">receive</code>, <code class="highlighter-rouge">fdwait</code>, <code class="highlighter-rouge">allocate</code>, <code class="highlighter-rouge">deallocate</code> and <code class="highlighter-rouge">random</code> with sys call numbers 1 to 7 respectively. Since these syscall numbers are used by the native Linux OS for other purposes, an emulation layer was created so that DECREE CB system calls are emulated using normal system calls. In short, <code class="highlighter-rouge">_terminate</code> calls <code class="highlighter-rouge">exit</code>, <code class="highlighter-rouge">transmit</code> and <code class="highlighter-rouge">receive</code> calls <code class="highlighter-rouge">write</code> and <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">fdwait</code> calls <code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">allocate</code> and <code class="highlighter-rouge">deallocate</code> calls <code class="highlighter-rouge">mmap</code> and <code class="highlighter-rouge">munmap</code>, and finally <code class="highlighter-rouge">random</code> is emulated using <code class="highlighter-rouge">/dev/random</code>. This is known as "Passthrough" mode in the emulation library.</p>
          
          <p>The emulation layer works by adding an Instruction Instrumentation Function that looks for any <code class="highlighter-rouge">int 0x80</code> instructions (what DECREE CBs use to make system calls). When one is found, it will then add a callback to the main emulation function to be called before the actual instruction is executed. The emulation layer will gather the system call parameters and emulate the requested call. Once completed, it will instruct PIN to skip the original system call instruction and continue execution by calling <code class="highlighter-rouge">PIN_ExecuteAt</code> at the next instruction.</p>
          
          <p>As a convenience, the emulation library can also work in an "Emulation" mode. This default "Passthrough" mode simply passes the DECREE syscalls through to the underlying system, e.g. <code class="highlighter-rouge">transmit</code> calls <code class="highlighter-rouge">write</code>. It works with the rest of the cb testing infrastructure such as cb-test, cb-replay and cb-server. On the other hand, the emulation mode works by redirecting all <code class="highlighter-rouge">transmit</code> and <code class="highlighter-rouge">receives</code> to reads and writes from files that the user can specify as parameters to the pintool.</p>
          
          <h3 id="using-the-library">Using the library</h3>
          
          <p>To use the emulation layer, all one needs to do is integrate the library source with their pintool while following these guidelines:</p>
          
          <p>First, there are some initialization code in <code class="highlighter-rouge">cgc_init</code> that needs to be called at the beginning. This is best achieved by adding the following source line to the main function</p>
          
          <div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">PIN_AddApplicationStartFunction</span><span class="p">(</span><span class="n">cgc_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>&#x000A;</code></pre>
          </div>
          
          <p>Second, make sure that the instruction callback is registered to instrument each instruction during translation time.</p>
          
          <div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">INS_AddInstrumentFunction</span><span class="p">(</span><span class="n">cgc_instrumentInstruction</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>&#x000A;</code></pre>
          </div>
          
          <p>Third, call the cleanup function when done</p>
          
          <div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">PIN_AddFiniFunction</span><span class="p">(</span><span class="n">cgc_cleanup</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;</code></pre>
          </div>
          
          <p>Fourth, make sure that the options for your pintool does not conflict with the options for the emulation layer.</p>
          
          <h2 id="building-the-decree-cb-compatible-sample-instruction-count-pintool">Building the DECREE CB Compatible Sample Instruction Count pintool</h2>
          
          <p>Building the DECREE CB Compatible pintool is fairly straight forward. Just follow the directions from the Intel PIN Manual. In short, it consists of:</p>
          
          <ol>
            <li>Copying the pintools distribution into the VM (copy it to the location of 
            the <code class="highlighter-rouge">Vagrantfile</code> on the host.)</li>
            <li>Replacing the <code class="highlighter-rouge">inscount0.cpp</code> file with the version that includes the 
            emulation library. OR integrate the emulation layer into the source code by
            following the instructions mentioned above. Don't forget to include 
            <code class="highlighter-rouge">libcgc_pin.h</code> as well.</li>
            <li>Make the pintool as normal</li>
          </ol>
          
          <h2 id="running-the-pintool">Running the pintool</h2>
          
          <p>This walk-through will illustrate how the instruction counter pintool on the <code class="highlighter-rouge">YAN01_00001</code> CB. To do so, first build the CB as normal. This will result in a DECREE binary that must be changed back into an ELF binary by changing the magic value back to ELF. Changing the magic value can be completed using the <code class="highlighter-rouge">cgc2elf</code> tool.</p>
          
          <div class="language-sh highlighter-rouge"><pre class="highlight"><code>mkdir bin/elf&#x000A;cp bin/YAN01_00001 bin/elf/YAN01_00001&#x000A;cgc2elf bin/elf/YAN01_00001&#x000A;</code></pre>
          </div>
          
          <p>This will create a new subdirectory called <code class="highlighter-rouge">elf</code> (to avoid clobbering the DECREE binary in <code class="highlighter-rouge">bin/</code>) and copy the binary into <code class="highlighter-rouge">bin/elf/</code>. The last command converts the cgc binary back to ELF.</p>
          
          <p>Once the magic value has been changed, the cb can then be run as normal with a pintool. For example, run YAN01_00001 as a normal program:</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ /vagrant/pin-2.14-67254-gcc.4.4.7-linux/pin -t /vagrant/pin-2.14-67254-gcc.4.4.7-linux/source/tools/ManualExamples/obj-ia32/inscount0.so -- bin/elf/YAN01_00001&#x000A;Player1:$ A&#x000A;Bad Command - Try again&#x000A;Player1:$ H&#x000A;Sorry, I am not very helpful&#x000A;Player1:$ e&#x000A;Bad Command - Try again&#x000A;Player1:$ ^C&#x000A;</code></pre>
          </div>
          
          <p>Check the logfile after running the sample.</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ more inscount.out&#x000A;Count 6239&#x000A;</code></pre>
          </div>
          
          <p>As mentioned previously, the emulation layer runs in "Passthrough" mode by default, meaning reads by the CB from fd of 0 will result in a read from stdin. Pipe in a list of commands from a file to illustrate this. Use the following generated poll as an example:</p>
          
          <div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" standalone="no" ?&gt;</span>&#x000A;<span class="cp">&lt;!DOCTYPE pov SYSTEM "/usr/share/cgc-replay/replay.dtd"&gt;</span>&#x000A;<span class="nt">&lt;pov&gt;</span>&#x000A;<span class="nt">&lt;cbid&gt;</span>service<span class="nt">&lt;/cbid&gt;</span>&#x000A;<span class="nt">&lt;replay&gt;</span>&#x000A;    <span class="nt">&lt;read&gt;&lt;length&gt;</span>10<span class="nt">&lt;/length&gt;&lt;match&gt;&lt;data&gt;</span>Player1:\x24 <span class="nt">&lt;/data&gt;&lt;/match&gt;&lt;/read&gt;</span>&#x000A;    <span class="nt">&lt;write&gt;&lt;data&gt;</span>P4IR2\x0a<span class="nt">&lt;/data&gt;&lt;/write&gt;</span>&#x000A;    <span class="nt">&lt;read&gt;&lt;length&gt;</span>10<span class="nt">&lt;/length&gt;&lt;match&gt;&lt;data&gt;</span>Player2:\x24 <span class="nt">&lt;/data&gt;&lt;/match&gt;&lt;/read&gt;</span>&#x000A;    <span class="nt">&lt;write&gt;&lt;data&gt;</span>E\x0a<span class="nt">&lt;/data&gt;&lt;/write&gt;</span>&#x000A;    <span class="nt">&lt;read&gt;&lt;delim&gt;</span>\x0a<span class="nt">&lt;/delim&gt;&lt;match&gt;&lt;data&gt;</span>You are stuck...\x0a<span class="nt">&lt;/data&gt;&lt;/match&gt;</span><span class="err">&lt;</span>/r&#x000A;ead&gt;&#x000A;    <span class="nt">&lt;read&gt;&lt;length&gt;</span>10<span class="nt">&lt;/length&gt;&lt;match&gt;&lt;data&gt;</span>Player2:\x24 <span class="nt">&lt;/data&gt;&lt;/match&gt;&lt;/read&gt;</span>&#x000A;    <span class="nt">&lt;write&gt;&lt;data&gt;</span>N\x0a<span class="nt">&lt;/data&gt;&lt;/write&gt;</span>&#x000A;    <span class="nt">&lt;read&gt;&lt;length&gt;</span>10<span class="nt">&lt;/length&gt;&lt;match&gt;&lt;data&gt;</span>Player1:\x24 <span class="nt">&lt;/data&gt;&lt;/match&gt;&lt;/read&gt;</span>&#x000A;    <span class="nt">&lt;write&gt;&lt;data&gt;</span>S\x0a<span class="nt">&lt;/data&gt;&lt;/write&gt;</span>&#x000A;    <span class="nt">&lt;read&gt;&lt;length&gt;</span>10<span class="nt">&lt;/length&gt;&lt;match&gt;&lt;data&gt;</span>Player1:\x24 <span class="nt">&lt;/data&gt;&lt;/match&gt;&lt;/read&gt;</span>&#x000A;<span class="nt">&lt;/replay&gt;</span>&#x000A;<span class="nt">&lt;/pov&gt;</span>&#x000A;</code></pre>
          </div>
          
          <p>The corresponding input file is:</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>P4IR2&#x000A;E&#x000A;N&#x000A;S&#x000A;</code></pre>
          </div>
          
          <p>Test this by issuing the following commands:</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ echo P4IR2 &gt;&gt; TESTINPUT&#x000A;$ echo E &gt;&gt; TESTINPUT&#x000A;$ echo N &gt;&gt; TESTINPUT&#x000A;$ echo S &gt;&gt; TESTINPUT&#x000A;$ /vagrant/pin-2.14-67254-gcc.4.4.7-linux/pin -t /vagrant/pin-2.14-67254-gcc.4.4.7-linux/source/tools/ManualExamples/obj-ia32/inscount0.so -- bin/elf/YAN01_00001 &lt; TESTINPUT&#x000A;Player1:$ Player2:$ You are stuck...&#x000A;Player2:$ Player1:$ Player1:$ ERROR reading from user -- time to die&#x000A;$ more inscount.out&#x000A;Count 10151&#x000A;</code></pre>
          </div>
          
          <p>Run the CB in emulation mode by directing fd 0 to be the file TESTINPUT. This is done by adding the "-e -fd 0,TESTINPUT" parameters to the pintool.</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ /vagrant/pin-2.14-67254-gcc.4.4.7-linux/pin -t /vagrant/pin-2.14-67254-gcc.4.4.7-linux/source/tools/ManualExamples/obj-ia32/inscount0.so -e -fd 0,TESTINPUT -- bin/elf/YAN01_00001&#x000A;Player1:$ Player2:$ You are stuck...&#x000A;Player2:$ Player1:$ Player1:$ ERROR reading from user -- time to die&#x000A;$ more inscount.out&#x000A;Count 10151&#x000A;</code></pre>
          </div>
          
          <h3 id="running-the-pintool-with-the-cb-infrastructure">Running the pintool with the cb infrastructure</h3>
          
          <p>Use the cb-server in 'wrapper' mode in order to run the pintool with the cb infrastructure. A wrapper is basically a program (or script) that is called by cb-server where the first parameter is the name of the cgc binary. This is needed because cb-server launches cgc binaries which do not take in parameters. The wrapper can be used to call external tools such as pin that require multiple input parameters.</p>
          
          <p>A shell script will be used as a wrapper in this walk-through.  The following is the shell script that is based on the above mention pin commands. It is placed into the 'bin/elf' directory.</p>
          
          <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/sh</span>&#x000A;<span class="c">#pin_wrap.sh</span>&#x000A;/vagrant/pin-2.14-67254-gcc.4.4.7-linux/pin -t /vagrant/pin-2.14-67254-gcc.4.4.7-linux/source/tools/ManualExamples/obj-ia32/inscount0.so -- <span class="nv">$1</span>&#x000A;</code></pre>
          </div>
          
          <p>Notice how the first parameter from cb-server was passed into the pintool.  Don't forget to make the script executable.</p>
          
          <div class="language-sh highlighter-rouge"><pre class="highlight"><code>chmod +x bin/elf/pin_wrap.sh&#x000A;</code></pre>
          </div>
          
          <p>The server can be started by passing in the '-w' flag once the wrapper script is complete.</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ cb-server --insecure -p 10000 -d bin/elf -w pin_wrap.sh YAN01_00001&#x000A;</code></pre>
          </div>
          
          <p>Use cb-replay to replay the xml file and check the number of instructions counted.</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ cb-replay --host 127.0.0.1 --port 10000 TESTINPUT.xml&#x000A;# service - TESTINPUT.xml&#x000A;ok 1 - bytes received&#x000A;ok 2 - match: string&#x000A;ok 3 - write: sent 6 bytes&#x000A;ok 4 - bytes received&#x000A;ok 5 - match: string&#x000A;ok 6 - write: sent 2 bytes&#x000A;ok 7 - match: string&#x000A;ok 8 - bytes received&#x000A;ok 9 - match: string&#x000A;ok 10 - write: sent 2 bytes&#x000A;ok 11 - bytes received&#x000A;ok 12 - match: string&#x000A;ok 13 - write: sent 2 bytes&#x000A;ok 14 - bytes received&#x000A;ok 15 - match: string&#x000A;# passed: 15&#x000A;# failed: 0&#x000A;# total passed: 15&#x000A;# total failed: 0&#x000A;&#x000A;$ more bin/elf/inscount.out&#x000A;Count 10151&#x000A;</code></pre>
          </div>
          
          <p>You can also run the pintool on a multi-binary CB the same way. The only thing to keep in mind is that the output file for the log should be different for each binary. As an example, cb-server will run the EAGLE_00004 CB with the following wrapper script.</p>
          
          <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/sh</span>&#x000A;<span class="c">#pin_wrap.sh</span>&#x000A;&#x000A;/vagrant/pin-2.14-67254-gcc.4.4.7-linux/pin -t /vagrant/pin-2.14-67254-gcc.4.4.7-linux/source/tools/ManualExamples/obj-ia32/inscount0.so -o inscount_<span class="nv">$1</span>.out -- <span class="nv">$1</span>&#x000A;</code></pre>
          </div>
          
          <p>Notice how the only difference between this script and the previous one is an additional option to the pintool to use unique log files.</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ cb-server --insecure -p 10000 -d bin/elf -w pin_wrap.sh EAGLE_00004_1 EAGLE_00004_2 EAGLE_00004_3&#x000A;</code></pre>
          </div>
          
          <p>cb-replay will be run as normal and before examining the resulting instruction counts from the pintool.</p>
          
          <div class="highlighter-rouge"><pre class="highlight"><code>$ cb-replay --debug --host 127.0.0.1 --port 10000 poller/for-release/poller-1.xml&#x000A;# EAGLE_00004 - poller/for-release/poller-1.xml&#x000A;ok 1 - write: sent 1905 bytes&#x000A;# received 'OUT: 0x2b15a909\n'&#x000A;ok 2 - match: string&#x000A;# received 'OUT: 0x9c369091\n'&#x000A;ok 3 - match: string&#x000A;# received 'OUT: 0xd1013543\n'&#x000A;...&#x000A;ok 83 - match: string&#x000A;# passed: 83&#x000A;# failed: 0&#x000A;# total passed: 83&#x000A;# total failed: 0&#x000A;</code></pre>
          </div>
          
          <h2 id="pintool-source">Pintool Source</h2>
          
          <h3 id="source-for-libcgcpinh">Source for libcgc_pin.h</h3>
          
          <div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#ifndef _LIBCGC_PIN_H&#x000A;#define _LIBCGC_PIN_H&#x000A;</span>&#x000A;<span class="c1">//NOTE: I just prefixed everything with CGC or cgc&#x000A;// so that these declarations are different from the standard (e.g. linux)&#x000A;// ones.&#x000A;</span>&#x000A;<span class="cp">#define CGC_STDIN 0&#x000A;#define CGC_STDOUT 1&#x000A;#define CGC_STDERR 2&#x000A;</span>&#x000A;<span class="cp">#ifndef NULL&#x000A;#define NULL ((void *)0)&#x000A;#endif&#x000A;</span>&#x000A;<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cgc_size_t</span><span class="p">;</span>&#x000A;<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="n">cgc_ssize_t</span><span class="p">;</span>&#x000A;&#x000A;<span class="cp">#define CGC_SSIZE_MAX       2147483647&#x000A;#define CGC_SIZE_MAX        4294967295&#x000A;#define CGC_FD_SETSIZE      1024&#x000A;</span>&#x000A;<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">cgc_fd_mask</span><span class="p">;</span>&#x000A;&#x000A;<span class="cp">#define CGC_NFDBITS (8 * sizeof(cgc_fd_mask))&#x000A;</span>&#x000A;<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>&#x000A;        <span class="n">cgc_fd_mask</span> <span class="n">_fd_bits</span><span class="p">[</span><span class="n">CGC_FD_SETSIZE</span> <span class="o">/</span> <span class="n">CGC_NFDBITS</span><span class="p">];</span>&#x000A;<span class="p">}</span> <span class="n">cgc_fd_set</span><span class="p">;</span>&#x000A;&#x000A;<span class="cp">#define CGC_FD_ZERO(set)                                                    \&#x000A;        do {                                                            \&#x000A;                cgc_size_t __i;                                                \&#x000A;                for (__i = 0; __i &lt; (CGC_FD_SETSIZE / CGC_NFDBITS); __i++)     \&#x000A;                        (set)-&gt;_fd_bits[__i] = 0;                               \&#x000A;        } while (0)&#x000A;#define CGC_FD_SET(b, set) \&#x000A;        ((set)-&gt;_fd_bits[b / CGC_NFDBITS] |= (1 &lt;&lt; (b &amp; (CGC_NFDBITS - 1))))&#x000A;#define CGC_FD_CLR(b, set) \&#x000A;        ((set)-&gt;_fd_bits[b / CGC_NFDBITS] &amp;= ~(1 &lt;&lt; (b &amp; (CGC_NFDBITS - 1))))&#x000A;#define CGC_FD_ISSET(b, set) \&#x000A;        ((set)-&gt;_fd_bits[b / CGC_NFDBITS] &amp; (1 &lt;&lt; (b &amp; (CGC_NFDBITS - 1))))&#x000A;</span>&#x000A;<span class="k">struct</span> <span class="n">cgc_timeval</span> <span class="p">{</span>&#x000A;        <span class="kt">int</span> <span class="n">tv_sec</span><span class="p">;</span>&#x000A;        <span class="kt">int</span> <span class="n">tv_usec</span><span class="p">;</span>&#x000A;<span class="p">};</span>&#x000A;&#x000A;<span class="cp">#define CGC_EBADF           1&#x000A;#define CGC_EFAULT          2&#x000A;#define CGC_EINVAL          3&#x000A;#define CGC_ENOMEM          4&#x000A;#define CGC_ENOSYS          5&#x000A;#define CGC_EPIPE           6&#x000A;</span>&#x000A;<span class="c1">//Some additional definitions&#x000A;</span><span class="cp">#define _TERMINATE 1&#x000A;#define _TRANSMIT 2&#x000A;#define _RECEIVE 3&#x000A;#define _FDWAIT 4&#x000A;#define _ALLOCATE 5&#x000A;#define _DEALLOCATE 6&#x000A;#define _RANDOM 7&#x000A;</span>&#x000A;<span class="cp">#define CGC_PAGE_SIZE	4096&#x000A;#define CGC_PAGE_MASK	(~(CGC_PAGE_SIZE - 1))&#x000A;</span>&#x000A;<span class="cp">#endif </span><span class="cm">/* _LIBCGC_PIN_H */</span><span class="cp">&#x000A;</span></code></pre>
          </div>
          
          <h3 id="source-for-inscount0cpp">Source for inscount0.cpp</h3>
          
          <div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cm">/** CGC Instruction Count Example&#x000A; *  @author Lok Yan&#x000A; *  @data 25 Aug 2014&#x000A;&#x000A; * Note that this was only tested on 32bit systems - we might need to fix some&#x000A; *  copying operations&#x000A;**/</span>&#x000A;&#x000A;<span class="cp">#include &lt;iostream&gt;&#x000A;#include &lt;fstream&gt;&#x000A;#include "pin.H"&#x000A;</span>&#x000A;&#x000A;<span class="cm">/********************************************/</span>&#x000A;<span class="cm">/** START OF CGC SYS_CALL EMULATOR SECTION **/</span>&#x000A;<span class="cm">/********************************************/</span>&#x000A;&#x000A;<span class="c1">//#include &lt;malloc.h&gt;&#x000A;</span><span class="cp">#include &lt;cstdlib&gt;&#x000A;#include &lt;unistd.h&gt; // for dup, write, etc.&#x000A;#include &lt;cerrno&gt;&#x000A;#include &lt;sys/mman.h&gt; // for mmap&#x000A;#include &lt;cstring&gt;&#x000A;#include &lt;cstdio&gt; //for fopen&#x000A;</span>&#x000A;<span class="c1">//Include the cgc definitions&#x000A;</span><span class="cp">#include "libcgc_pin.h"&#x000A;</span>&#x000A;<span class="c1">//a mode that passes the syscalls directly through to the kernel&#x000A;</span><span class="n">KNOB</span><span class="o">&lt;</span><span class="n">BOOL</span><span class="o">&gt;</span> <span class="n">KnobModePassthrough</span><span class="p">(</span><span class="n">KNOB_MODE_WRITEONCE</span><span class="p">,</span> <span class="s">"pintool"</span><span class="p">,</span>&#x000A;  <span class="s">"p"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"Syscall passthrough mode"</span><span class="p">);</span>&#x000A;&#x000A;<span class="c1">//a mode that emulates the system calls using file inputs&#x000A;</span><span class="n">KNOB</span><span class="o">&lt;</span><span class="n">BOOL</span><span class="o">&gt;</span> <span class="n">KnobModeEmulation</span><span class="p">(</span><span class="n">KNOB_MODE_WRITEONCE</span><span class="p">,</span> <span class="s">"pintool"</span><span class="p">,</span>&#x000A;  <span class="s">"e"</span><span class="p">,</span> <span class="s">"0"</span><span class="p">,</span> <span class="s">"Syscall emulation mode"</span><span class="p">);</span>&#x000A;<span class="n">KNOB</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">KnobFDMap</span><span class="p">(</span><span class="n">KNOB_MODE_APPEND</span><span class="p">,</span> <span class="s">"pintool"</span><span class="p">,</span>&#x000A;  <span class="s">"fd"</span><span class="p">,</span> <span class="s">""</span> <span class="p">,</span> <span class="s">"File descriptor number to file mappings, </span><span class="se">\n</span><span class="s">"</span>&#x000A;             <span class="s">"</span><span class="se">\t</span><span class="s">  e.g., -fd 0,mystdin will use 'mystdin' as input to fd 0</span><span class="se">\n</span><span class="s">"</span>&#x000A;             <span class="s">"</span><span class="se">\t</span><span class="s">        -fd 0,mystdin -fd 1,mystdout will use 'mystdin' as input to 0 and 'mystdout' to 1"</span><span class="p">);</span>&#x000A;<span class="n">KNOB</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">KnobRandFile</span><span class="p">(</span><span class="n">KNOB_MODE_WRITEONCE</span><span class="p">,</span> <span class="s">"pintool"</span><span class="p">,</span>&#x000A;  <span class="s">"rand"</span><span class="p">,</span> <span class="s">"/dev/urandom"</span><span class="p">,</span> <span class="s">"Filename for the source of random bytes"</span><span class="p">);</span>&#x000A;&#x000A;<span class="c1">//NOTE: We are going to use a MAP for now - but perhaps a clean implementation will have&#x000A;// a smaller footprint&#x000A;</span><span class="cm">/* -- unordered_map is unsupported in cgc vm&#x000A;#include &lt;unordered_map&gt;&#x000A;typedef std::unordered_map&lt;int, FILE*&gt; fd_map_t;&#x000A;*/</span>&#x000A;&#x000A;<span class="cp">#include &lt;map&gt;&#x000A;</span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*&gt;</span> <span class="n">fd_map_t</span><span class="p">;</span>&#x000A;<span class="n">fd_map_t</span> <span class="n">cgc_fds</span><span class="p">;</span> <span class="c1">//faster than a regular map&#x000A;</span>&#x000A;<span class="kt">FILE</span><span class="o">*</span> <span class="n">randfd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>&#x000A;&#x000A;<span class="n">VOID</span> <span class="nf">cgc_cleanup_files</span><span class="p">()</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="c1">//close all of the open files&#x000A;</span>  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cgc_fds</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">fd_map_t</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">cgc_fds</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>&#x000A;    <span class="n">fclose</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>&#x000A;    <span class="n">cgc_fds</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">randfd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">fclose</span><span class="p">(</span><span class="n">randfd</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * This function is called before the analysis target is loaded&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">cgc_init</span><span class="p">(</span><span class="n">VOID</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="c1">//0. Make sure that the size of fd_set and cgc_fd_set are the same&#x000A;</span>  <span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd_set</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">))</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"ERROR!!! The sizeof native fd_set and cgc_fd_set are not the same"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;    <span class="n">cgc_cleanup_files</span><span class="p">();</span>&#x000A;    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//1. First, we want to open up the randomness source&#x000A;</span>  <span class="c1">//The default value for KnobRandFile is /dev/urandom so KnobRandFile should always be well&#x000A;</span>  <span class="c1">// defined&#x000A;</span>  <span class="n">randfd</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">KnobRandFile</span><span class="p">.</span><span class="n">Value</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="s">"rb"</span><span class="p">);</span>&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">randfd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"The random source file ["</span> <span class="o">&lt;&lt;</span> <span class="n">KnobRandFile</span><span class="p">.</span><span class="n">Value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"] could not be opened"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;    <span class="n">cgc_cleanup_files</span><span class="p">();</span>&#x000A;    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//2. Next we want to see if emulation mode is enabled, if so then open up the rest of the files&#x000A;</span>  <span class="c1">//if we are going to emulate, then we would like to load the files corresponding&#x000A;</span>  <span class="c1">// to the defined fd numbers&#x000A;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">KnobModeEmulation</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="c1">//NOTE: All files are opened for read/write and in binary mode&#x000A;</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KnobFDMap</span><span class="p">.</span><span class="n">NumberOfValues</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span> <span class="o">=</span> <span class="n">KnobFDMap</span><span class="p">.</span><span class="n">Value</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>&#x000A;      <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">commaPos</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">','</span><span class="p">);</span>&#x000A;&#x000A;      <span class="kt">int</span> <span class="n">fdnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;&#x000A;      <span class="cm">/** std::stoi doesn't seem to exist in the cgc VM either -- so switching to strtol&#x000A;      try&#x000A;      {&#x000A;        fdnum = std::stoi(str.substr(0, commaPos - 1));&#x000A;      }&#x000A;      catch (std::invalid_argument e)&#x000A;      {&#x000A;        cerr &lt;&lt; "Invalid argument received [" &lt;&lt; str &lt;&lt; "]" &lt;&lt; endl;&#x000A;        cgc_cleanup_files();&#x000A;        exit(-1);&#x000A;      }&#x000A;      **/</span>&#x000A;&#x000A;      <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cstr</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>&#x000A;      <span class="kt">char</span><span class="o">*</span> <span class="n">tempp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>&#x000A;&#x000A;      <span class="n">fdnum</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">cstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>&#x000A;      <span class="c1">//I am counting on some initial tests that shows strtol will stop at&#x000A;</span>      <span class="c1">// the , if conversion was good and it will go beyond it if conversion&#x000A;</span>      <span class="c1">// was unsuccessful&#x000A;</span>      <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">tempp</span> <span class="o">!=</span> <span class="p">(</span><span class="n">cstr</span> <span class="o">+</span> <span class="n">commaPos</span><span class="p">))</span> <span class="p">)</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Could not convert the fd in ["</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">"]"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;        <span class="n">cgc_cleanup_files</span><span class="p">();</span>&#x000A;        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>&#x000A;      <span class="p">}</span>&#x000A;&#x000A;      <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">commaPos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="n">c_str</span><span class="p">(),</span> <span class="s">"r+b"</span><span class="p">);</span>&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Could not open file ["</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">commaPos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"] for rw"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;        <span class="n">cgc_cleanup_files</span><span class="p">();</span>&#x000A;        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>&#x000A;      <span class="p">}</span>&#x000A;&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">cgc_fds</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fdnum</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cgc_fds</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="c1">//if it exists already then errror&#x000A;</span>        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"The file for fd ["</span> <span class="o">&lt;&lt;</span> <span class="n">fdnum</span> <span class="o">&lt;&lt;</span> <span class="s">"] has already beed defined"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;        <span class="n">cgc_cleanup_files</span><span class="p">();</span>&#x000A;        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>&#x000A;      <span class="p">}</span>&#x000A;&#x000A;      <span class="c1">//everything checks out so add in the new entry&#x000A;</span>      <span class="n">cgc_fds</span><span class="p">[</span><span class="n">fdnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>&#x000A;    <span class="p">}</span><span class="c1">//end for KnobFDMap.NumberOfValues&#x000A;</span>  <span class="p">}</span><span class="c1">//END if emulation&#x000A;</span>&#x000A;  <span class="cm">/** INSERT PINTOOLS INITIALIZATIONS HERE **/</span>&#x000A;  <span class="cm">/** END PINTOOLS INITIALIZATION SECTION **/</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * This function is called when the program ends&#x000A; * That is BEFORE the terminate system call is called&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">cgc_cleanup</span><span class="p">(</span><span class="n">INT32</span> <span class="n">code</span><span class="p">,</span> <span class="n">VOID</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="n">cgc_cleanup_files</span><span class="p">();</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;&#x000A;&#x000A;<span class="cp">#define CGC_SET_RETURN(_ctx, _val) PIN_SetContextReg(_ctx, REG_EAX, _val)&#x000A;</span>&#x000A;<span class="cm">/**&#x000A; * This function is called if the system call number is 1 (_terminate)&#x000A; * Notice that we don't need to do anything here because 1 is also&#x000A; *   the system call number for sys_exit in 32bit linux.&#x000A; * If the host is 64bit, then we will need to change the sys_call number&#x000A; *   to the proper value. Might have to fix the register values as well.&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">emulate_terminate</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * Emulation function for sys call 2 (transmit)&#x000A; * The basic idea is that, we can either pass this call through to the host&#x000A; *   in which case we will need to worry about the file descriptors being&#x000A; *   shared between the pintool and the analysis target. We get around this&#x000A; *   problem by writing our own wrapper launcher that will preallocate the&#x000A; *   file descriptors that the analysis target might need before transferring&#x000A; *   control to the pintool. This way, the fds used by the pintools will be&#x000A; *   above the ones needed by the CB.&#x000A; * The other method is to emulate the file descriptors. This works by changing&#x000A; *   all transmits into fwrites into the files that the user have defined&#x000A; *   using the -fd #,filename arguments. If an argument was not defined, then&#x000A; *   we default to passthrough mode (e.g. when user only passes in -fd 0,input.txt&#x000A; *   we will emulate receive from fd 0 with a fread from input.txt but we will&#x000A; *   just pass transmits to fd 1 right into stdout.)&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">emulate_transmit</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="n">cgc_size_t</span> <span class="n">stemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;&#x000A;  <span class="kt">size_t</span> <span class="n">stret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="kt">ssize_t</span> <span class="n">sstret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">return</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//int transmit(int fd, const void *buf, size_t count, size_t *tx_bytes);&#x000A;</span>  <span class="n">ADDRINT</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EBX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ECX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">count</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EDX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ESI</span><span class="p">);</span>&#x000A;&#x000A;&#x000A;  <span class="cm">/**&#x000A;       EBADF    fd is not a valid file  descriptor&#x000A;                or is not open.&#x000A;       EFAULT   buf   or  tx_bytes  points  to  an&#x000A;                invalid address.&#x000A;  **/</span>&#x000A;&#x000A;  <span class="c1">//TODO: Make sure that the error logic is the same as in the kernel&#x000A;</span>  <span class="c1">// For example, right now we make sure that tx_bytes is writeable first&#x000A;</span>  <span class="c1">// before actually calling write.&#x000A;</span>&#x000A;  <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tx_bytes</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">stemp</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">tx_bytes</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">))</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;      <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//we will try the emulation mode first - since not all fds might be defined&#x000A;</span>  <span class="c1">// for the ones that are not defined - we want to just pass through&#x000A;</span>&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">KnobModeEmulation</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="c1">//in this case, we want to send it out to a file instead of using write&#x000A;</span>    <span class="n">fd_map_t</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">cgc_fds</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">cgc_fds</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="c1">//if it exists then process&#x000A;</span>    <span class="p">{</span>&#x000A;      <span class="n">stret</span> <span class="o">=</span> <span class="n">fwrite</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">count</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>&#x000A;&#x000A;      <span class="c1">//NOTE: is there anything to do with the return value?&#x000A;</span>      <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="c1">//TODO:what to return if there is an error?&#x000A;</span>      <span class="p">}</span>&#x000A;&#x000A;      <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tx_bytes</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tx_bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">stret</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">));</span> <span class="c1">//this should work&#x000A;</span>      <span class="p">}</span>&#x000A;&#x000A;      <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;      <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="c1">//if the entry is not found then just pass it through&#x000A;</span>  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//PASSTHROUGH MODE - KnobModePassthrough is always TRUE&#x000A;</span>  <span class="c1">//if we are just passing it through then call write&#x000A;</span>  <span class="n">sstret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">sstret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// we wrote something so set the return to 0&#x000A;</span>&#x000A;    <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tx_bytes</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tx_bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">sstret</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">));</span> <span class="c1">//this should work&#x000A;</span>    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;  <span class="k">else</span> <span class="c1">// an error occurred&#x000A;</span>  <span class="p">{</span>&#x000A;    <span class="k">switch</span> <span class="p">(</span><span class="n">sstret</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">):</span>&#x000A;      <span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="n">EBADF</span><span class="p">):</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EBADF</span><span class="p">);</span>&#x000A;        <span class="k">break</span><span class="p">;</span>&#x000A;      <span class="p">}</span>&#x000A;      <span class="nl">default:</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;        <span class="k">break</span><span class="p">;</span>&#x000A;      <span class="p">}</span>&#x000A;    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="nl">SKIP_INT:</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">curIP</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">);</span>&#x000A;&#x000A;  <span class="c1">//int 0x80 is cd 80 in hex which is two bytes&#x000A;</span>  <span class="c1">//get the parameters off the stack first&#x000A;</span>  <span class="n">PIN_SetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">,</span> <span class="n">curIP</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>&#x000A;  <span class="n">PIN_ExecuteAt</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> <span class="c1">//execute after the instruction&#x000A;</span><span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * Function to emulate syscall 3 (receive)&#x000A; * See the comments for emulate_transmit&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">emulate_receive</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="n">cgc_size_t</span> <span class="n">stemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="kt">size_t</span> <span class="n">stret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="kt">ssize_t</span> <span class="n">sstret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">return</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//int receive(int fd, void *buf, size_t count, size_t *rx_bytes)&#x000A;</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EBX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ECX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">count</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EDX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ESI</span><span class="p">);</span>&#x000A;&#x000A;  <span class="cm">/**&#x000A;       EBADF    fd is not a valid file  descriptor&#x000A;                or is not open.&#x000A;       EFAULT   buf   or  rx_bytes  points  to  an&#x000A;                invalid address.&#x000A;  **/</span>&#x000A;&#x000A;  <span class="c1">//TODO: Make sure that the error logic is the same as in the kernel&#x000A;</span>  <span class="c1">// For example, right now we make sure that rx_bytes is writeable first&#x000A;</span>  <span class="c1">// before actually calling write.&#x000A;</span>&#x000A;  <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">rx_bytes</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">stemp</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">rx_bytes</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">))</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;      <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">KnobModeEmulation</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="c1">//in this case, we want to read from a file&#x000A;</span>    <span class="n">fd_map_t</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">cgc_fds</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">cgc_fds</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="c1">//if it exists then process&#x000A;</span>    <span class="p">{</span>&#x000A;      <span class="n">stret</span> <span class="o">=</span> <span class="n">fread</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">count</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>&#x000A;&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//if there is an error&#x000A;</span>      <span class="p">{</span>&#x000A;        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">))</span>&#x000A;        <span class="p">{</span>&#x000A;          <span class="c1">//TODO: What to do if there is an error - and not just the end of file?&#x000A;</span>        <span class="p">}</span>&#x000A;      <span class="p">}</span>&#x000A;      <span class="c1">//NOTE: is there anything to do with the return value?&#x000A;</span>      <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">rx_bytes</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">rx_bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">stret</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">));</span> <span class="c1">//this should work&#x000A;</span>      <span class="p">}</span>&#x000A;&#x000A;      <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;      <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="c1">//if the entry is not found then just pass it through&#x000A;</span>  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//PASSTHROUGH MODE&#x000A;</span>  <span class="c1">//if we are just passing it through then call write&#x000A;</span>  <span class="n">sstret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">sstret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// we wrote something so set the return to 0&#x000A;</span>&#x000A;    <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">rx_bytes</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">rx_bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">sstret</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">));</span> <span class="c1">//this should work&#x000A;</span>    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;  <span class="k">else</span> <span class="c1">// an error occurred&#x000A;</span>  <span class="p">{</span>&#x000A;    <span class="k">switch</span> <span class="p">(</span><span class="n">sstret</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">):</span>&#x000A;      <span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="n">EBADF</span><span class="p">):</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EBADF</span><span class="p">);</span>&#x000A;        <span class="k">break</span><span class="p">;</span>&#x000A;      <span class="p">}</span>&#x000A;      <span class="nl">default:</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;        <span class="k">break</span><span class="p">;</span>&#x000A;      <span class="p">}</span>&#x000A;    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="nl">SKIP_INT:</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">curIP</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">);</span>&#x000A;&#x000A;  <span class="c1">//int 0x80 is cd 80 in hex which is two bytes&#x000A;</span>  <span class="c1">//get the parameters off the stack first&#x000A;</span>  <span class="n">PIN_SetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">,</span> <span class="n">curIP</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>&#x000A;  <span class="n">PIN_ExecuteAt</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> <span class="c1">//execute after the instruction&#x000A;</span><span class="p">}</span>&#x000A;&#x000A;&#x000A;&#x000A;<span class="kt">int</span> <span class="nf">CGC_FD_IS_SET_EMPTY</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="o">*</span> <span class="n">set</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="n">cgc_size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">CGC_FD_SETSIZE</span> <span class="o">/</span> <span class="n">CGC_NFDBITS</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">_fd_bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>&#x000A;    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * This emulates syscall 4 (fdwait)&#x000A; * Since fdwait is just like select, we will pass through&#x000A; *   the parameters directly to select. This assumes that&#x000A; *   the definitions for fd_set are the same between the CGC binary&#x000A; *   and the host system. We do a quick and dirty check by&#x000A; *   making sure that they are the same size. The definitions for FD_SETSIZE and&#x000A; *   CGC_FD_SETSIZE might be different.&#x000A; * If we are running in emulation mode, then what we do is just&#x000A; *   set the file descriptors ourselves as long as the fd number&#x000A; *   to file map is defined. If it is not defined then we pass&#x000A; *   the undefined fds to select.&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">emulate_fdwait</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="kt">int</span> <span class="n">iret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="kt">int</span> <span class="n">numReady</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="kt">size_t</span> <span class="n">stret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;&#x000A;  <span class="n">cgc_fd_set</span> <span class="n">tempReadSet</span><span class="p">;</span>&#x000A;  <span class="n">cgc_fd_set</span><span class="o">*</span> <span class="n">pTempReadSet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>&#x000A;  <span class="n">cgc_fd_set</span> <span class="n">tempWriteSet</span><span class="p">;</span>&#x000A;  <span class="n">cgc_fd_set</span><span class="o">*</span> <span class="n">pTempWriteSet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>&#x000A;&#x000A;  <span class="n">cgc_fd_set</span> <span class="n">retReadSet</span><span class="p">;</span>&#x000A;  <span class="n">cgc_fd_set</span><span class="o">*</span> <span class="n">pRetReadSet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>&#x000A;  <span class="n">cgc_fd_set</span> <span class="n">retWriteSet</span><span class="p">;</span>&#x000A;  <span class="n">cgc_fd_set</span><span class="o">*</span> <span class="n">pRetWriteSet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>&#x000A;&#x000A;  <span class="cm">/**&#x000A;  int  fdwait(int nfds, fd_set *readfds, fd_set *writefds, const struct timeval *timeout,&#x000A;       int *readyfds);&#x000A;  **/</span>&#x000A;&#x000A;  <span class="n">ADDRINT</span> <span class="n">nfds</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EBX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">readfds</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ECX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">writefds</span>  <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EDX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ESI</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">readyfds</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EDI</span><span class="p">);</span>&#x000A;&#x000A;  <span class="cm">/**&#x000A;       EBADF    an  invalid file descriptor was&#x000A;                given in one of the sets  (per&#x000A;                haps a file descriptor that was&#x000A;                already closed, or one on which&#x000A;                an error has occurred).&#x000A;       EINVAL   nfds  is  negative or the value&#x000A;                contained  within  *timeout  is&#x000A;                invalid.&#x000A;&#x000A;       EFAULT   One  of  the arguments readfds,&#x000A;                writefds,   timeout,   readyfds&#x000A;                points to an invalid address.&#x000A;       ENOMEM   unable  to  allocate memory for&#x000A;                internal tables.&#x000A;  **/</span>&#x000A;&#x000A;&#x000A;  <span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">nfds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EINVAL</span><span class="p">);</span>&#x000A;    <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//NOTE: We are enforcing the less than CGC_FD_SETSIZE which might not be what&#x000A;</span>  <span class="c1">// the kernel is doing&#x000A;</span>  <span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">nfds</span> <span class="o">&gt;</span> <span class="n">CGC_FD_SETSIZE</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EINVAL</span><span class="p">);</span>&#x000A;    <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//first we make a copy of the fd_set lists&#x000A;</span>  <span class="k">if</span> <span class="p">((</span><span class="n">cgc_fd_set</span><span class="o">*</span><span class="p">)</span><span class="n">readfds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">pTempReadSet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tempReadSet</span><span class="p">;</span>&#x000A;    <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pTempReadSet</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">readfds</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">));</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">))</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;      <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="c1">//we also want the retReadSet to be zeroed out&#x000A;</span>    <span class="c1">// it will be set as fds are ready&#x000A;</span>    <span class="n">pRetReadSet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">retReadSet</span><span class="p">;</span>&#x000A;    <span class="n">CGC_FD_ZERO</span><span class="p">(</span><span class="n">pRetReadSet</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">((</span><span class="n">cgc_fd_set</span><span class="o">*</span><span class="p">)</span><span class="n">writefds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">pTempWriteSet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tempWriteSet</span><span class="p">;</span>&#x000A;    <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pTempWriteSet</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">writefds</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">));</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">))</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;      <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="n">pRetWriteSet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">retWriteSet</span><span class="p">;</span>&#x000A;    <span class="n">CGC_FD_ZERO</span><span class="p">(</span><span class="n">pRetWriteSet</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//now we should have pTempReadSet and pTrempWriteSet pointing to copies&#x000A;</span>  <span class="c1">// of the corresponding sets - OR NULL&#x000A;</span>&#x000A;  <span class="c1">//So lets go through emulation mode first and see if there are any fds that&#x000A;</span>  <span class="c1">// are already mapped&#x000A;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">KnobModeEmulation</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nfds</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">cgc_fds</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cgc_fds</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="c1">//if the file exists - then remove the set bit now&#x000A;</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pTempReadSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;        <span class="p">{</span>&#x000A;          <span class="c1">//if we are watching this particular fd&#x000A;</span>          <span class="k">if</span> <span class="p">(</span><span class="n">CGC_FD_ISSET</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pTempReadSet</span><span class="p">))</span>&#x000A;          <span class="p">{</span>&#x000A;            <span class="c1">//clear the corresponding bit in case we need to call select later&#x000A;</span>            <span class="n">CGC_FD_CLR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pTempReadSet</span><span class="p">);</span>&#x000A;            <span class="c1">//but also set the same bit in the return set&#x000A;</span>            <span class="n">CGC_FD_SET</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pRetReadSet</span><span class="p">);</span>&#x000A;            <span class="c1">//increment the number of Ready fds&#x000A;</span>            <span class="n">numReady</span><span class="o">++</span><span class="p">;</span>&#x000A;          <span class="p">}</span>&#x000A;        <span class="p">}</span>&#x000A;&#x000A;        <span class="c1">//do the same for the write set&#x000A;</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pTempWriteSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;        <span class="p">{</span>&#x000A;          <span class="c1">//if we are watching this particular fd&#x000A;</span>          <span class="k">if</span> <span class="p">(</span><span class="n">CGC_FD_ISSET</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pTempWriteSet</span><span class="p">))</span>&#x000A;          <span class="p">{</span>&#x000A;            <span class="c1">//clear the corresponding bit in case we need to call select later&#x000A;</span>            <span class="n">CGC_FD_CLR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pTempWriteSet</span><span class="p">);</span>&#x000A;            <span class="c1">//but also set the same bit in the return set&#x000A;</span>            <span class="n">CGC_FD_SET</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pRetWriteSet</span><span class="p">);</span>&#x000A;            <span class="n">numReady</span><span class="o">++</span><span class="p">;</span>&#x000A;          <span class="p">}</span>&#x000A;        <span class="p">}</span>&#x000A;      <span class="p">}</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="c1">//At this point in time - temp*Set should be the left over any real fds that we don't have a&#x000A;</span>    <span class="c1">// file mapping to. We don't change nfds because one of the unmapped fds could be at the end&#x000A;</span>    <span class="c1">//TODO: Finally, note that the above logic WILL NOT WORK for read-only or write-only fds&#x000A;</span>    <span class="c1">// such as 0, 1, and 2. They will be counted twice since all files are opened as read and&#x000A;</span>    <span class="c1">// writeable.&#x000A;</span>  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//PASSTHROUGH MODE&#x000A;</span>  <span class="cm">/**&#x000A;  static int asmlinkage&#x000A;  cgcos_fdwait(int nfds, fd_set __user *readfds, fd_set __user *writefds,&#x000A;               struct timeval __user *timeout, int __user *readyfds) {&#x000A;    int res;&#x000A;    if (readyfds != NULL &amp;&amp;&#x000A;        !access_ok(VERIFY_WRITE, readyfds, sizeof(*readyfds)))&#x000A;      return (-EFAULT);&#x000A;&#x000A;    res = sys_select(nfds, readfds, writefds, NULL, timeout);&#x000A;&#x000A;    if (res &lt; 0)&#x000A;      return (res);&#x000A;&#x000A;    if (readyfds != NULL &amp;&amp; copy_to_user(readyfds, &amp;res, sizeof(*readyfds)))&#x000A;      return (-EFAULT);&#x000A;&#x000A;    return (0);&#x000A;  }&#x000A;  **/</span>&#x000A;&#x000A;  <span class="c1">//if its emulation mode - then we want to skip this if the fdsets are now empty&#x000A;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">CGC_FD_IS_SET_EMPTY</span><span class="p">(</span><span class="n">pTempReadSet</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CGC_FD_IS_SET_EMPTY</span><span class="p">(</span><span class="n">pTempWriteSet</span><span class="p">))</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="c1">//if they are both empty then just skip the select step but to make sure iret is 0&#x000A;</span>    <span class="n">iret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;  <span class="k">else</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">iret</span> <span class="o">=</span> <span class="n">select</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">nfds</span><span class="p">,</span> <span class="p">(</span><span class="n">fd_set</span><span class="o">*</span><span class="p">)</span><span class="n">pTempReadSet</span><span class="p">,</span> <span class="p">(</span><span class="n">fd_set</span><span class="o">*</span><span class="p">)</span><span class="n">pTempWriteSet</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span><span class="o">*</span><span class="p">)</span><span class="n">timeout</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//if its emulation mode we need to combine the results&#x000A;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">iret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="c1">//either way - if select failed then an error occurred so we will just ignore&#x000A;</span>    <span class="c1">// all of temporary work we did above with the temporary knobs&#x000A;</span>    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">iret</span><span class="p">);</span>&#x000A;    <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;  <span class="k">else</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="n">KnobModeEmulation</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">numReady</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">iret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="c1">//if its emulation mode AND we have some fds that are set AND select set some more&#x000A;</span>        <span class="c1">// then we need to merge the previous results with the ones from tempRead and WriteSets&#x000A;</span>        <span class="k">for</span> <span class="p">(</span><span class="n">cgc_size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">CGC_FD_SETSIZE</span> <span class="o">/</span> <span class="n">CGC_NFDBITS</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>&#x000A;        <span class="p">{</span>&#x000A;          <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pRetReadSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pTempReadSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//the two points should be consistent&#x000A;</span>          <span class="p">{</span>&#x000A;            <span class="n">pRetReadSet</span><span class="o">-&gt;</span><span class="n">_fd_bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">pTempReadSet</span><span class="o">-&gt;</span><span class="n">_fd_bits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>&#x000A;          <span class="p">}</span>&#x000A;          <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pRetWriteSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pTempWriteSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span>&#x000A;          <span class="p">{</span>&#x000A;            <span class="n">pRetWriteSet</span><span class="o">-&gt;</span><span class="n">_fd_bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">pTempWriteSet</span><span class="o">-&gt;</span><span class="n">_fd_bits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>&#x000A;          <span class="p">}</span>&#x000A;        <span class="p">}</span>&#x000A;      <span class="p">}</span>&#x000A;&#x000A;      <span class="c1">//We also need to update the total number&#x000A;</span>      <span class="n">numReady</span> <span class="o">+=</span> <span class="n">iret</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">else</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="c1">//since KnobModeEmulation was not set or there weren't anything of interest&#x000A;</span>      <span class="c1">// we can just set the return pointers to the tempSets that we passed into select&#x000A;</span>      <span class="n">pRetReadSet</span> <span class="o">=</span> <span class="n">pTempReadSet</span><span class="p">;</span>&#x000A;      <span class="n">pRetWriteSet</span> <span class="o">=</span> <span class="n">pTempWriteSet</span><span class="p">;</span>&#x000A;      <span class="n">numReady</span> <span class="o">=</span> <span class="n">iret</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="c1">//by now pRetReadSet and pRetWriteSet should have all of the bits for ready fds&#x000A;</span>    <span class="c1">// set and numReady has the number of fds that are ready&#x000A;</span>&#x000A;    <span class="c1">//Lets copy back to the user&#x000A;</span>    <span class="k">if</span> <span class="p">(</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">readfds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pRetReadSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//once again these should be consistently NULL or non NULL at the same time.&#x000A;</span>    <span class="p">{</span>&#x000A;      <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">readfds</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pRetReadSet</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">));</span>&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">))</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;        <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;      <span class="p">}</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="k">if</span> <span class="p">(</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">writefds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pRetWriteSet</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span> <span class="c1">//once again these should be consistently NULL or non NULL at the same time.&#x000A;</span>    <span class="p">{</span>&#x000A;      <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">writefds</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pRetWriteSet</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">));</span>&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_fd_set</span><span class="p">))</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;        <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;      <span class="p">}</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">readyfds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">readyfds</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">numReady</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>&#x000A;      <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;        <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;      <span class="p">}</span>&#x000A;    <span class="p">}</span>&#x000A;&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//success&#x000A;</span>  <span class="p">}</span><span class="c1">//end else error from select&#x000A;</span>&#x000A;  <span class="nl">SKIP_INT:</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">curIP</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">);</span>&#x000A;&#x000A;  <span class="c1">//int 0x80 is cd 80 in hex which is two bytes&#x000A;</span>  <span class="c1">//get the parameters off the stack first&#x000A;</span>  <span class="n">PIN_SetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">,</span> <span class="n">curIP</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>&#x000A;  <span class="n">PIN_ExecuteAt</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> <span class="c1">//execute after the instruction&#x000A;</span><span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * allocate is a wrapper of sorts for mmap so we just pass&#x000A; *   this one through mmap. There is no difference between emulation&#x000A; *   and passthrough mode at the moment.&#x000A; * As one would expect, and is well documented, the allocation&#x000A; *   behavior is going to be different between the CGC binary running&#x000A; *   in PIN and one running natively by itself.&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">emulate_allocate</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">return</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//int allocate(size_t length, int is_X, void **addr)&#x000A;</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">len</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EBX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">is_X</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ECX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EDX</span><span class="p">);</span>&#x000A;&#x000A;  <span class="cm">/**&#x000A;       EINVAL   length is zero.&#x000A;       EINVAL   length is too large.&#x000A;       EFAULT   addr   points   to  an  invalid&#x000A;                address.&#x000A;       ENOMEM   No memory is available  or  the&#x000A;                process'   maximum   number  of&#x000A;                allocations  would  have   been&#x000A;                exceeded.&#x000A;  **/</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EINVAL</span><span class="p">);</span>&#x000A;    <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;    <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//try to read from the target address first to see if the memory address is valid&#x000A;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">PIN_SafeCopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">addr</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ADDRINT</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ADDRINT</span><span class="p">))</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;    <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//if we are here then the addr is valid so lets call mmap&#x000A;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span> <span class="o">|</span> <span class="p">(</span><span class="n">is_X</span> <span class="o">?</span> <span class="n">PROT_EXEC</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANON</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EINVAL</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;  <span class="k">else</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="nl">SKIP_INT:</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">curIP</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">);</span>&#x000A;&#x000A;  <span class="c1">//int 0x80 is cd 80 in hex which is two bytes&#x000A;</span>  <span class="c1">//get the parameters off the stack first&#x000A;</span>  <span class="n">PIN_SetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">,</span> <span class="n">curIP</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>&#x000A;  <span class="n">PIN_ExecuteAt</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> <span class="c1">//execute after the instruction&#x000A;</span><span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * See emulate_allocate for more info&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">emulate_deallocate</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">return</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//int deallocate(void *addr, size_t length)&#x000A;</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EBX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">len</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ECX</span><span class="p">);</span>&#x000A;&#x000A;  <span class="cm">/**&#x000A;       EINVAL   addr is not page aligned.&#x000A;       EINVAL   length is zero.&#x000A;       EINVAL   any part of  the  region  being&#x000A;                deallocated   is   outside  the&#x000A;                valid  address  range  of   the&#x000A;                process.&#x000A;  **/</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">CGC_PAGE_MASK</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EINVAL</span><span class="p">);</span>&#x000A;    <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="n">ret</span> <span class="o">=</span> <span class="n">munmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EINVAL</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;  <span class="k">else</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="nl">SKIP_INT:</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">curIP</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">);</span>&#x000A;&#x000A;  <span class="c1">//int 0x80 is cd 80 in hex which is two bytes&#x000A;</span>  <span class="c1">//get the parameters off the stack first&#x000A;</span>  <span class="n">PIN_SetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">,</span> <span class="n">curIP</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>&#x000A;  <span class="n">PIN_ExecuteAt</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> <span class="c1">//execute after the instruction&#x000A;</span><span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * According to the kernel documentation there are three&#x000A; *   ways to get_random_bytes - the first is the kernel function&#x000A; *   with the same name, the second is from the user space through&#x000A; *   /dev/random and the third is from /dev/urandom&#x000A; *   Since there isn't a direct sys_call for random, we will emulate&#x000A; *   this from the userspace.&#x000A; * According to the source in linux-source-3.13.2-cgc/drivers/char/random.c&#x000A; *   get_random_bytes calls extract_entropy using the nonblocking_pool&#x000A; *   /dev/random calls the userspace version using the blocking_pool&#x000A; *   /dev/urandom calls it using the nonblocking_pool&#x000A; *   and so, we will use /dev/urandom as the randomness source&#x000A; * No matter the mode, randfd should be pointing to the right file or&#x000A; *   /dev/urandom&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">emulate_random</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="kt">size_t</span> <span class="n">stret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;  <span class="c1">//int random(void *buf, size_t count, size_t *rnd_bytes)&#x000A;</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EBX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">count</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_ECX</span><span class="p">);</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">rnd_bytes</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EDX</span><span class="p">);</span>&#x000A;&#x000A;  <span class="cm">/**&#x000A;    EINVAL   count is invalid.&#x000A;    EFAULT   buf  or  rnd_bytes points to an&#x000A;                invalid address.&#x000A;  */</span>&#x000A;&#x000A;  <span class="n">stret</span> <span class="o">=</span> <span class="n">fread</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">count</span><span class="p">,</span> <span class="n">randfd</span><span class="p">);</span>&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="c1">//an error has occurred&#x000A;</span>  <span class="p">{</span>&#x000A;    <span class="c1">//first we check to see if eof has been reached&#x000A;</span>    <span class="k">if</span> <span class="p">(</span><span class="n">feof</span><span class="p">(</span><span class="n">randfd</span><span class="p">))</span> <span class="c1">//this should only happen if fdrand is a file, /dev/urandom should not give us an eof&#x000A;</span>    <span class="p">{</span>&#x000A;      <span class="kt">size_t</span> <span class="n">bytesLeft</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">count</span> <span class="o">-</span> <span class="n">stret</span><span class="p">;</span>&#x000A;      <span class="n">fseek</span><span class="p">(</span><span class="n">randfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span> <span class="c1">//go back to the beginning of the file&#x000A;</span>      <span class="n">stret</span> <span class="o">=</span> <span class="n">fread</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">stret</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bytesLeft</span><span class="p">,</span> <span class="n">randfd</span><span class="p">);</span> <span class="c1">//read again&#x000A;</span>      <span class="k">if</span> <span class="p">(</span><span class="n">stret</span> <span class="o">&lt;</span> <span class="n">bytesLeft</span><span class="p">)</span> <span class="c1">//another error - then just die&#x000A;</span>      <span class="p">{</span>&#x000A;        <span class="c1">//TODO: How to die? Neither EINVAL nor EFAULT seems to be the right thing to do&#x000A;</span>      <span class="p">}</span>&#x000A;      <span class="k">else</span>&#x000A;      <span class="p">{</span>&#x000A;        <span class="c1">//success so set the return value and go&#x000A;</span>        <span class="k">goto</span> <span class="n">SUCCESS</span><span class="p">;</span> <span class="c1">//not really needed&#x000A;</span>      <span class="p">}</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">else</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="c1">//NOTE: We will just assume that buf is wrong&#x000A;</span>      <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="n">CGC_EFAULT</span><span class="p">);</span>&#x000A;      <span class="k">goto</span> <span class="n">SKIP_INT</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="nl">SUCCESS:</span>&#x000A;  <span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">rnd_bytes</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;&#x000A;    <span class="n">stret</span> <span class="o">=</span> <span class="n">PIN_SafeCopy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">rnd_bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cgc_size_t</span><span class="p">));</span>&#x000A;    <span class="n">CGC_SET_RETURN</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="nl">SKIP_INT:</span>&#x000A;  <span class="n">ADDRINT</span> <span class="n">curIP</span> <span class="o">=</span> <span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">);</span>&#x000A;&#x000A;  <span class="c1">//int 0x80 is cd 80 in hex which is two bytes&#x000A;</span>  <span class="c1">//get the parameters off the stack first&#x000A;</span>  <span class="n">PIN_SetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EIP</span><span class="p">,</span> <span class="n">curIP</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>&#x000A;  <span class="n">PIN_ExecuteAt</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> <span class="c1">//execute after the instruction&#x000A;</span><span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * Our own small little syscall handler&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">cgc_syscallHandler</span><span class="p">(</span><span class="n">CONTEXT</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">return</span><span class="p">;</span>&#x000A;  <span class="p">}</span>&#x000A;&#x000A;  <span class="c1">//Check the syscall number&#x000A;</span>  <span class="k">switch</span><span class="p">(</span><span class="n">PIN_GetContextReg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">REG_EAX</span><span class="p">))</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">case</span> <span class="p">(</span><span class="n">_TERMINATE</span><span class="p">):</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">emulate_terminate</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>&#x000A;      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">case</span> <span class="p">(</span><span class="n">_TRANSMIT</span><span class="p">):</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">emulate_transmit</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>&#x000A;      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">case</span> <span class="p">(</span><span class="n">_RECEIVE</span><span class="p">):</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">emulate_receive</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>&#x000A;      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">case</span> <span class="p">(</span><span class="n">_FDWAIT</span><span class="p">):</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">emulate_fdwait</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>&#x000A;      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">case</span> <span class="p">(</span><span class="n">_ALLOCATE</span><span class="p">):</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">emulate_allocate</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>&#x000A;      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">case</span> <span class="p">(</span><span class="n">_DEALLOCATE</span><span class="p">):</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">emulate_deallocate</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>&#x000A;      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="k">case</span> <span class="p">(</span><span class="n">_RANDOM</span><span class="p">):</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="n">emulate_random</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>&#x000A;      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;    <span class="nl">default:</span>&#x000A;    <span class="p">{</span>&#x000A;      <span class="c1">//TODO: Right now we don't do anything,&#x000A;</span>      <span class="c1">// meaning we just pass the syscall through&#x000A;</span>      <span class="c1">//This is not the right behavior, since an&#x000A;</span>      <span class="c1">// undefined cgc syscall is actually defined&#x000A;</span>      <span class="c1">// on Linux which is the context that PIN is running under&#x000A;</span>      <span class="k">break</span><span class="p">;</span>&#x000A;    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/**&#x000A; * We need an instruction handler so we can skip the int 0x80 instructions&#x000A;**/</span>&#x000A;<span class="n">VOID</span> <span class="nf">cgc_instrumentInstruction</span><span class="p">(</span><span class="n">INS</span> <span class="n">ins</span><span class="p">,</span> <span class="n">VOID</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;  <span class="c1">//NOTE: Instead of using INS_isSyscall we will look for int 0x80 instead&#x000A;</span>  <span class="c1">//We could use INT_isInterrupt as well, but that covers more opcodes&#x000A;</span>  <span class="c1">// than just INT Immediate&#x000A;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">INS_Opcode</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="o">==</span> <span class="n">XED_ICLASS_INT</span><span class="p">)</span>&#x000A;  <span class="p">{</span>&#x000A;    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">INS_OperandIsImmediate</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1">//its an immediate operand&#x000A;</span>         <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">INS_OperandImmediate</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">)</span> <span class="c1">//and its 0x80&#x000A;</span>       <span class="p">)</span>&#x000A;    <span class="p">{</span>&#x000A;&#x000A;      <span class="n">INS_InsertCall</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">IPOINT_BEFORE</span><span class="p">,</span> <span class="p">(</span><span class="n">AFUNPTR</span><span class="p">)</span><span class="n">cgc_syscallHandler</span><span class="p">,</span>&#x000A;                     <span class="n">IARG_CALL_ORDER</span><span class="p">,</span> <span class="n">CALL_ORDER_FIRST</span><span class="p">,</span> <span class="c1">//NOTE: We want to be called first, but you can change it&#x000A;</span>                     <span class="n">IARG_CONTEXT</span><span class="p">,</span>&#x000A;                     <span class="n">IARG_END</span>&#x000A;                    <span class="p">);</span>&#x000A;&#x000A;      <span class="c1">//NOTE: We don't just delete the instruction at this point - we will update&#x000A;</span>      <span class="c1">// the PC and then call PIN_ExecuteAt to bypass these instructions later&#x000A;</span>    <span class="p">}</span>&#x000A;  <span class="p">}</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/********************************************/</span>&#x000A;<span class="cm">/** END OF EMULATION SECTION **/</span>&#x000A;<span class="cm">/********************************************/</span>&#x000A;&#x000A;<span class="cm">/*BEGIN_LEGAL&#x000A;Intel Open Source License&#x000A;&#x000A;Copyright (c) 2002-2014 Intel Corporation. All rights reserved.&#x000A;&#x000A;Redistribution and use in source and binary forms, with or without&#x000A;modification, are permitted provided that the following conditions are&#x000A;met:&#x000A;&#x000A;Redistributions of source code must retain the above copyright notice,&#x000A;this list of conditions and the following disclaimer.  Redistributions&#x000A;in binary form must reproduce the above copyright notice, this list of&#x000A;conditions and the following disclaimer in the documentation and/or&#x000A;other materials provided with the distribution.  Neither the name of&#x000A;the Intel Corporation nor the names of its contributors may be used to&#x000A;endorse or promote products derived from this software without&#x000A;specific prior written permission.&#x000A;&#x000A;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&#x000A;``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&#x000A;LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&#x000A;A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR&#x000A;ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&#x000A;SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&#x000A;LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&#x000A;DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&#x000A;THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&#x000A;(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&#x000A;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&#x000A;END_LEGAL */</span>&#x000A;&#x000A;<span class="n">ofstream</span> <span class="n">OutFile</span><span class="p">;</span>&#x000A;&#x000A;<span class="c1">// The running count of instructions is kept here&#x000A;// make it static to help the compiler optimize docount&#x000A;</span><span class="k">static</span> <span class="n">UINT64</span> <span class="n">icount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>&#x000A;&#x000A;<span class="c1">// This function is called before every instruction is executed&#x000A;</span><span class="n">VOID</span> <span class="nf">docount</span><span class="p">()</span> <span class="p">{</span> <span class="n">icount</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>&#x000A;&#x000A;<span class="c1">// Pin calls this function every time a new instruction is encountered&#x000A;</span><span class="n">VOID</span> <span class="nf">Instruction</span><span class="p">(</span><span class="n">INS</span> <span class="n">ins</span><span class="p">,</span> <span class="n">VOID</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;    <span class="c1">// Insert a call to docount before every instruction, no arguments are passed&#x000A;</span>    <span class="n">INS_InsertCall</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">IPOINT_BEFORE</span><span class="p">,</span> <span class="p">(</span><span class="n">AFUNPTR</span><span class="p">)</span><span class="n">docount</span><span class="p">,</span> <span class="n">IARG_END</span><span class="p">);</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="n">KNOB</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">KnobOutputFile</span><span class="p">(</span><span class="n">KNOB_MODE_WRITEONCE</span><span class="p">,</span> <span class="s">"pintool"</span><span class="p">,</span>&#x000A;    <span class="s">"o"</span><span class="p">,</span> <span class="s">"inscount.out"</span><span class="p">,</span> <span class="s">"specify output file name"</span><span class="p">);</span>&#x000A;&#x000A;<span class="c1">// This function is called when the application exits&#x000A;</span><span class="n">VOID</span> <span class="nf">Fini</span><span class="p">(</span><span class="n">INT32</span> <span class="n">code</span><span class="p">,</span> <span class="n">VOID</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>&#x000A;<span class="p">{</span>&#x000A;    <span class="c1">// Write to a file since cout and cerr maybe closed by the application&#x000A;</span>    <span class="n">OutFile</span><span class="p">.</span><span class="n">setf</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">showbase</span><span class="p">);</span>&#x000A;    <span class="n">OutFile</span> <span class="o">&lt;&lt;</span> <span class="s">"Count "</span> <span class="o">&lt;&lt;</span> <span class="n">icount</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;    <span class="n">OutFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/* ===================================================================== */</span>&#x000A;<span class="cm">/* Print Help Message                                                    */</span>&#x000A;<span class="cm">/* ===================================================================== */</span>&#x000A;&#x000A;<span class="n">INT32</span> <span class="nf">Usage</span><span class="p">()</span>&#x000A;<span class="p">{</span>&#x000A;    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"This tool counts the number of dynamic instructions executed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">KNOB_BASE</span><span class="o">::</span><span class="n">StringKnobSummary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>&#x000A;    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>&#x000A;<span class="p">}</span>&#x000A;&#x000A;<span class="cm">/* ===================================================================== */</span>&#x000A;<span class="cm">/* Main                                                                  */</span>&#x000A;<span class="cm">/* ===================================================================== */</span>&#x000A;<span class="cm">/*   argc, argv are the entire command line: pin -t &lt;toolname&gt; -- ...    */</span>&#x000A;<span class="cm">/* ===================================================================== */</span>&#x000A;&#x000A;<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>&#x000A;<span class="p">{</span>&#x000A;    <span class="c1">// Initialize pin&#x000A;</span>    <span class="k">if</span> <span class="p">(</span><span class="n">PIN_Init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">))</span> <span class="k">return</span> <span class="n">Usage</span><span class="p">();</span>&#x000A;&#x000A;    <span class="n">OutFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">KnobOutputFile</span><span class="p">.</span><span class="n">Value</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>&#x000A;&#x000A;    <span class="n">PIN_AddApplicationStartFunction</span><span class="p">(</span><span class="n">cgc_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>&#x000A;&#x000A;    <span class="cm">/** ADD CGC CALLBACK **/</span>&#x000A;    <span class="n">INS_AddInstrumentFunction</span><span class="p">(</span><span class="n">cgc_instrumentInstruction</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>&#x000A;&#x000A;    <span class="c1">// Register Instruction to be called to instrument instructions&#x000A;</span>    <span class="n">INS_AddInstrumentFunction</span><span class="p">(</span><span class="n">Instruction</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;&#x000A;    <span class="c1">// Register Fini to be called when the application exits&#x000A;</span>    <span class="n">PIN_AddFiniFunction</span><span class="p">(</span><span class="n">Fini</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;    <span class="n">PIN_AddFiniFunction</span><span class="p">(</span><span class="n">cgc_cleanup</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>&#x000A;&#x000A;    <span class="c1">// Start the program, never returns&#x000A;</span>    <span class="n">PIN_StartProgram</span><span class="p">();</span>&#x000A;&#x000A;    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>&#x000A;<span class="p">}</span>&#x000A;</code></pre>
          </div>
        </div>
      </div>
    </div>
    <footer>
      <div id='impressum'>Published by Legitimate Business Syndicate</div>
      <div id='timestamp'>Built at 2016-05-20T17:40:31Z</div>
      <div>
        <ul>
          <li><a href="https://legitbs.net">Homepage</a></li>
          <li><a href="https://twitter.com/legitbs_ctf">Twitter</a></li>
          <li><a href="https://github.com/legitbs">GitHub</a></li>
          <li><a href="https://github.com/legitbs/cgc-docs">This repo</a></li>
        </ul>
      </div>
    </footer>
    <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="../../../assets/javascripts/application.js"></script>
  </body>
</html>
